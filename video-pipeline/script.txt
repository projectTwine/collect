WEBVTT
Kind: captions
Language: en

00:00:01.640 --> 00:00:04.520
&gt;&gt; (Phillip Roberts) hello, come in and sit
down.

00:00:04.520 --> 00:00:10.300
So for the last session before the afternoon
break, we have Phillip Roberts who works at

00:00:10.300 --> 00:00:12.820
Andea and is here from London&nbsp;‑‑ Scotland.

00:00:12.820 --> 00:00:13.820
Edinbrough.

00:00:13.820 --> 00:00:17.510
&nbsp;‑‑ wow, ten second memory, he's going
to talk about the vent loop.

00:00:17.510 --> 00:00:18.599
If everyone could give Phillip a big brownedder
round of applause.

00:00:18.599 --> 00:00:20.939
&gt;&gt; Phillip Roberts: Okay hello everyone, thanks
for coming to the side track, it's awesome

00:00:20.939 --> 00:00:22.630
to see it packed out in here.

00:00:22.630 --> 00:00:24.820
Can everyone give me a stretch.

00:00:24.820 --> 00:00:31.810
I needed to stretch, so I look less weird.

00:00:31.810 --> 00:00:37.219
I want to talk about the event loop and what
the heck is the event loop, as in the event

00:00:37.219 --> 00:00:39.620
loop inside JavaScript.

00:00:39.620 --> 00:00:46.899
So first up, as he said I work for AndYet
which is an awesome little Dev shop in the

00:00:46.899 --> 00:00:50.750
US, look us up if you need help with real‑time
stuff.

00:00:50.750 --> 00:00:52.260
That's what we're good at.

00:00:52.260 --> 00:01:00.000
So, about 18 months ago--I'm a paid professional
JavaScript developer--I thought to myself

00:01:00.000 --> 00:01:03.980
how does, like JavaScript actually work?

00:01:03.980 --> 00:01:05.850
And I wasn't entirely sure.

00:01:05.850 --> 00:01:12.720
I'd heard V8 as a term, chrome's Runtime didn't
really know what that meant, what that did.

00:01:12.720 --> 00:01:16.270
I'd heard things like single threaded, you
know obviously I'm using callbacks.

00:01:16.270 --> 00:01:17.970
How do callbacks work?

00:01:17.970 --> 00:01:25.250
I started a journey of like reading and research
and experimenting in the browser which basically

00:01:25.250 --> 00:01:26.250
started like this.

00:01:26.250 --> 00:01:30.540
&nbsp;‑‑ I was kind of like JavaScript what
are you.

00:01:30.540 --> 00:01:35.680
I'm a single threaded single concurrent language&nbsp;‑‑
right.

00:01:35.680 --> 00:01:41.060
yeah, cool, I have a call stack, an event
loop, a callback queue, and some other APIs

00:01:41.060 --> 00:01:42.619
and stuff.

00:01:42.619 --> 00:01:43.619
&nbsp;‑‑ rite.

00:01:43.619 --> 00:01:45.259
I did not do a computer science degree.

00:01:45.259 --> 00:01:51.420
I mean, these words, they're words, so I heard
about V8 and the various Runtimes and different

00:01:51.420 --> 00:01:55.870
browsers so I looked to V8 do you have a call
stack, an event loop, a callback queue, and

00:01:55.870 --> 00:02:00.299
some other APIs and stuff, I have a call stack
and a heap, I don't know what those other

00:02:00.299 --> 00:02:09.679
things are, okay, interesting so basically
18 months passed.

00:02:09.679 --> 00:02:12.550
And I think I get this.

00:02:12.550 --> 00:02:15.970
(Laughing) and so, this is what I want to
share with you today.

00:02:15.970 --> 00:02:21.510
Hopefully this will be useful if you're relatively
new to JavaScript, help you understand why

00:02:21.510 --> 00:02:26.060
JavaScript is so weird when you compare it
to other languages you might used why callbacks

00:02:26.060 --> 00:02:29.290
are a thing, cause us hell but are required.

00:02:29.290 --> 00:02:35.540
And if you're an experienced JavaScript developer
hopefully give you some fresh insights how

00:02:35.540 --> 00:02:40.890
the Runtime you're using works so you can
think about it a little better.

00:02:40.890 --> 00:02:51.380
So if we look at the JavaScript Runtime itself
like V8 which is the Runtime inside Chrome.

00:02:51.380 --> 00:02:55.129
This is a simplified view of what JavaScript
Runtime is.

00:02:55.129 --> 00:03:01.849
The heap, where memory allocation happens,
and then there's the call stack, which is

00:03:01.849 --> 00:03:09.930
where your stack frames are and all that kind
of stuff, but, if you, like, clone the V8

00:03:09.930 --> 00:03:17.720
code base and grep for things like setTimeout
or DOM or HTTP request, they're not in there,

00:03:17.720 --> 00:03:21.380
they don't exist in V8, which was a surprise
to me.

00:03:21.380 --> 00:03:27.930
It's first thing you use when you start thinking
about async stuff and it's not in the V8 source.

00:03:27.930 --> 00:03:29.390
Hmm ... interesting.

00:03:29.390 --> 00:03:35.860
So, over this 18 months of discovery I come
to realize this is really, this is really

00:03:35.860 --> 00:03:40.049
the bigger picture, this is what I'm hoping
to get you on board with today and understand

00:03:40.049 --> 00:03:45.099
what these pieces are, we have the V8 Runtime
but then we have these things called web APIs

00:03:45.099 --> 00:03:47.910
which are extra things that the browser provides.

00:03:47.910 --> 00:03:54.860
DOM, AJAX, time out, things like that, we
have this mythical event loop and the callback

00:03:54.860 --> 00:03:55.860
queue.

00:03:55.860 --> 00:03:59.430
I'm sure you've heard some of these terms
before, but maybe you don't quite understand

00:03:59.430 --> 00:04:01.870
how these pieces pull together.

00:04:01.870 --> 00:04:06.629
So, I'm going to start from the beginning,
some of this will be new, to words might be

00:04:06.629 --> 00:04:08.890
new to people, other people will get this.

00:04:08.890 --> 00:04:13.940
We're going to quickly move on from here,
bear with me if this is obvious, I think for

00:04:13.940 --> 00:04:16.180
a lot of people it's not.

00:04:16.180 --> 00:04:21.290
So, JavaScript is a single threaded programming
language, single threaded Runtime, it has

00:04:21.290 --> 00:04:23.390
a single call stack.

00:04:23.390 --> 00:04:28.570
And it can do one thing at a time, that's
what a single thread means, the program can

00:04:28.570 --> 00:04:30.920
run one piece of code at a time.

00:04:30.920 --> 00:04:35.390
So, let's try and visualize that just to get
our heads around what that mean, so if I have

00:04:35.390 --> 00:04:40.850
some code like this on your left, we've got
a few functions, a function multiplier which

00:04:40.850 --> 00:04:46.570
multiplies two numbers, square which calls
multiply with the same number twice, a function

00:04:46.570 --> 00:04:51.700
which prints the square of a number of calling
square and then calling console.log and then

00:04:51.700 --> 00:04:55.860
at the bottom of our file we actually run
print square, this code all good?

00:04:55.860 --> 00:04:56.860
Make sense?

00:04:56.860 --> 00:04:57.860
Cool.

00:04:57.860 --> 00:05:04.440
So, if we run this, well, I should back up
a step, so the call stack is basically&nbsp;‑‑

00:05:04.440 --> 00:05:08.660
it's a data structure which records basically
where in the program we are, if we step into

00:05:08.660 --> 00:05:12.800
a function, we put something on to the stack,
if we return from a function, we pop off the

00:05:12.800 --> 00:05:18.621
top of the stack that's all the stack can
do,&nbsp;‑‑ so if you run this file, there's

00:05:18.621 --> 00:05:23.470
kind of a main function, right, like the file
itself, so, we push that on to the stack.

00:05:23.470 --> 00:05:28.450
Then we have some function definitions, they're
just like defining the state of the world,

00:05:28.450 --> 00:05:32.770
and finally we got to print square, right,
so print square is a function call, so we

00:05:32.770 --> 00:05:37.710
push that on to the stack, and immediately
inside print square, push on to the stack,

00:05:37.710 --> 00:05:43.940
which calls multiply, now we have a return
statement, we multiply A and B and we return,

00:05:43.940 --> 00:05:48.990
when we return we pop something off the stack,
so, pop, multiplier of the stack, returning

00:05:48.990 --> 00:05:57.040
to square, return to print square, console.log,
there's no return, it's implicit, because

00:05:57.040 --> 00:06:01.680
we got to the end of the function, and we're
done so that's like a visualization of the

00:06:01.680 --> 00:06:05.090
call stalk, does that make sense?

00:06:05.090 --> 00:06:11.830
(Yes, Phil) even if you haven't thought about
the call stack before, you've come across

00:06:11.830 --> 00:06:18.050
it when you've been doing browser‑side development,
so if we have code like this, a function baz

00:06:18.050 --> 00:06:26.990
which calls bar, which calls Foo, which throws
an error if we run it in Chrome we see this.

00:06:26.990 --> 00:06:32.050
And it prints the stack trace, right, the
state of the stack when that error happened,

00:06:32.050 --> 00:06:40.400
so, uncaught error oops Foo, bar, Baz, anonymous
function, which is our main.

00:06:40.400 --> 00:06:46.300
Equally, if you've heard the term like blowing
the stack, this is an example of that.

00:06:46.300 --> 00:06:52.830
Have a function foo which calls Foo , so what's
going to happen ? We have a function main

00:06:52.830 --> 00:07:00.870
which calls foo which calls foo, which calls
foo, which calls foo, and ultimately chrome

00:07:00.870 --> 00:07:07.460
says, you probably didn't mean to call foo
16,000 times recursively, I'll just kill things

00:07:07.460 --> 00:07:10.710
for you and you can figure out where your
bug lies, right.

00:07:10.710 --> 00:07:16.580
So although I may be representing a new side
of the call stack you have some sense of it

00:07:16.580 --> 00:07:18.740
in your development practice already.

00:07:18.740 --> 00:07:24.440
So, the big question then comes is like what
happens when things are slow?

00:07:24.440 --> 00:07:31.220
So, we talk about blocking and blocking behavior
and blocking, there's no strict definition

00:07:31.220 --> 00:07:35.830
of what is and didn't blocking, really it's
just code that's slow.

00:07:35.830 --> 00:07:41.230
So console.log isn't slow, doing a while loop
from one to ten billion is slow, network requests

00:07:41.230 --> 00:07:42.230
are slow.

00:07:42.230 --> 00:07:46.330
Image requests are slow.

00:07:46.330 --> 00:07:52.010
Things which are slow and on that stack are
what are blocking means.

00:07:52.010 --> 00:07:59.120
So heres a little example, so let's say we
have, this is like a fake bit of code, getSynchronous,

00:07:59.120 --> 00:08:03.850
right, like jQuery is like, AJAX request.

00:08:03.850 --> 00:08:07.340
What would happen if those were synchronous
requests, forget what we know about async

00:08:07.340 --> 00:08:10.160
callbacks they're synchronous.

00:08:10.160 --> 00:08:16.190
If we go through it like we have, we call
getSync and then we wait, because then we're

00:08:16.190 --> 00:08:21.940
doing network request, network is relative
to computers, are slow, hopefully that network

00:08:21.940 --> 00:08:27.810
requests completes, we can move on, wait,
move on.

00:08:27.810 --> 00:08:37.080
Wait, and, I mean, this network request might
never finish, so ... yeah, I guess I'll go

00:08:37.080 --> 00:08:38.080
home.

00:08:38.080 --> 00:08:43.030
Finally those three, you know blocking behaviors
complete and we can clear the stack, right.

00:08:43.030 --> 00:08:49.901
So in a programming language is single threaded
you're not using threads like say Ruby, that's

00:08:49.901 --> 00:08:54.320
what happens, right, we make a network request,
we have to just wait till it's done, because

00:08:54.320 --> 00:08:56.900
we have no way of handling that.

00:08:56.900 --> 00:09:00.210
Why is this actually a problem?

00:09:00.210 --> 00:09:04.360
The problem is because we're running code
in browsers.

00:09:04.360 --> 00:09:10.709
So, let's you ‑‑ here we go, okay.

00:09:10.709 --> 00:09:15.940
So this is just, this is Chrome, this is the
code I just ran.

00:09:15.940 --> 00:09:20.720
Browsers don't give us&nbsp;‑‑ well they do
give us synchronous AJAX request, I'm faking

00:09:20.720 --> 00:09:26.120
this out with a big while loop, because it's
synchronous, I basically while loop for five

00:09:26.120 --> 00:09:33.960
seconds before continuing, so if I open up
the console here.

00:09:33.960 --> 00:09:40.600
We can see what happens, so with request foo.com,
why this is happening, I can't do anything,

00:09:40.600 --> 00:09:44.760
right, even the run button hasn't finished
rerendering the fact that I clicked it.

00:09:44.760 --> 00:09:51.490
The browser is blocked, it's stuck, it can't
do anything until those requests complete.

00:09:51.490 --> 00:09:55.681
And then all hell breaks loose because I did
some stuff,it figured that out I'd done it,

00:09:55.681 --> 00:09:58.800
it couldn't actually render it.

00:09:58.800 --> 00:10:00.520
Couldn't do anything.

00:10:00.520 --> 00:10:07.010
That's because if that call stack has things
on it, and here it's got these yeah, it's

00:10:07.010 --> 00:10:08.420
still going.

00:10:08.420 --> 00:10:12.260
We've got the synchronous request, the browser
can't do anything else.

00:10:12.260 --> 00:10:16.800
It can't render, it can't run any other code,
it's stuck.

00:10:16.800 --> 00:10:22.110
Not ideal, right if we want people to have
nice fluid UIs, we can't block the stack.

00:10:22.110 --> 00:10:24.650
So, how do we handle this?

00:10:24.650 --> 00:10:29.280
Well the simplest solution we're provided
with is asynchronous callbacks, there's almost

00:10:29.280 --> 00:10:36.570
no blocking functions in the browser, equally
in node, they're all made asynchronous, which

00:10:36.570 --> 00:10:42.180
basically means we run some code, give it
a callback, and run that later, if you've

00:10:42.180 --> 00:10:47.430
seen JavaScript you've seen asynchronous callbacks,
what does this actually look like.

00:10:47.430 --> 00:10:51.130
Simple example to remind people where we're
at.

00:10:51.130 --> 00:10:53.530
Code like this, console.log hi.

00:10:53.530 --> 00:11:00.390
Write, we run the setTimeout, but that queue's
the console log for future so we skip on to

00:11:00.390 --> 00:11:06.540
JSConf and then five seconds later we log
"there" right, make sense?

00:11:06.540 --> 00:11:07.540
Happy.

00:11:07.540 --> 00:11:09.670
Basically that's setTimeout is doing something.

00:11:09.670 --> 00:11:15.040
So, asynchronous callbacks with regards to
the stacks we saw before ... how does this

00:11:15.040 --> 00:11:16.760
work?

00:11:16.760 --> 00:11:18.480
Let's run the code.

00:11:18.480 --> 00:11:22.540
Console.log hi. setTimeout.

00:11:22.540 --> 00:11:28.370
We know it doesn't run immediately, we know
it's going to run in five seconds time, we

00:11:28.370 --> 00:11:34.070
can't push it on to the stack, somehow it
just disappears, we don't have like a way

00:11:34.070 --> 00:11:37.240
of describing this yet, but we'll come to
it.

00:11:37.240 --> 00:11:44.810
We log JSConfEU, clear, five seconds later
somehow magically "there" appears on the stack.

00:11:44.810 --> 00:11:48.960
How does that happen?

00:11:48.960 --> 00:11:53.710
And that's&nbsp;‑‑ this is basically where
the event loop comes in on concurrency.

00:11:53.710 --> 00:11:58.760
Right, so I've been kind of partially lying
do you and telling you that JavaScript can

00:11:58.760 --> 00:12:00.050
only do one thing at one time.

00:12:00.050 --> 00:12:03.660
That's true the JavaScript Runtime can only
do one thing at one time.

00:12:03.660 --> 00:12:06.120
It can't make an AJAX request while you're
doing other code.

00:12:06.120 --> 00:12:09.380
It can't do a setTimeout while you're doing
another code.

00:12:09.380 --> 00:12:15.000
The reason we can do things concurrently is
that the browser is more than just the Runtime.

00:12:15.000 --> 00:12:19.420
So, remember this diagram, the JavaScript
Runtime can do one thing at a time, but the

00:12:19.420 --> 00:12:23.840
browser gives us these other things, gives
us these we shall APIs, these are effectively

00:12:23.840 --> 00:12:31.110
threads, you can just make calls to, and those
pieces of the browser are aware of this concurrency

00:12:31.110 --> 00:12:33.060
kicks in.

00:12:33.060 --> 00:12:38.150
If you're back end person this diagram looks
basically identical for node, instead of web

00:12:38.150 --> 00:12:48.680
APIs we have C++ APIs and the threading is
being hidden from you by C++.

00:12:48.680 --> 00:12:53.520
Now we have this picture let's see how this
code runs in a more full picture of what a

00:12:53.520 --> 00:12:54.630
browser looks like.

00:12:54.630 --> 00:13:01.930
So, same as before, run code, console log
hi, logs hi to the console, simple.

00:13:01.930 --> 00:13:05.029
now we can see what happens when we call setTimeout.

00:13:05.029 --> 00:13:11.680
We are&nbsp;‑‑ we pass this callback function
and a delay to the setTimeout call.

00:13:11.680 --> 00:13:17.210
Now setTimeout is an API provided to us by
the browser, it doesn't live in the V8 source,

00:13:17.210 --> 00:13:22.630
it's extra stuff we
get in that we're running the JavaScript run

00:13:22.630 --> 00:13:25.180
time in.

00:13:25.180 --> 00:13:27.660
The browser kicks off a timer for you.

00:13:27.660 --> 00:13:33.150
And now it's going to handle the count down
for you, right, so that means our setTimeout

00:13:33.150 --> 00:13:37.100
call, itself is now complete, so we can pop
off the stack.

00:13:37.100 --> 00:13:45.460
“JSConfEU”, clear, so, now we've got this
timer in the web API, which five seconds later

00:13:45.460 --> 00:13:46.920
is going to complete.

00:13:46.920 --> 00:13:52.930
Now the web API can't just start modifying
your code, it can't chuck stuff onto the stack

00:13:52.930 --> 00:13:58.339
when it's ready if it did it would appear
randomly in the middle of your code so this

00:13:58.339 --> 00:14:00.550
is where the task queue or callback queue
kicks in.

00:14:00.550 --> 00:14:07.880
Any of the web APIs pushes the callback on
to the task queue when it's done.

00:14:07.880 --> 00:14:12.930
Finally we get to the event loop, title of
the talk, what the heck is the event loop

00:14:12.930 --> 00:14:18.530
is like the simplest little piece in this
whole equation, and it has one very simple

00:14:18.530 --> 00:14:19.530
job.

00:14:19.530 --> 00:14:22.710
The event loops job is to look at the stack
and look at the task queue.

00:14:22.710 --> 00:14:26.839
If the stack is empty it takes the first thing
on the queue and pushes it on to the stack

00:14:26.839 --> 00:14:29.250
which effectively run it.

00:14:29.250 --> 00:14:34.440
So here we can see that now the stack is clear,
there's a callback on the task queue, the

00:14:34.440 --> 00:14:39.810
event loop runs, it says, oh, I get to do
something, pushes the callback on to the stack.

00:14:39.810 --> 00:14:45.180
Remember it's the stack is like JavaScript
land, back inside V8, the callback appears

00:14:45.180 --> 00:14:49.780
on the stack, run, console.log “there”,
and we're done.

00:14:49.780 --> 00:14:52.150
Does that make sense?

00:14:52.150 --> 00:14:53.930
Everyone where me?

00:14:53.930 --> 00:14:54.930
Awesome!

00:14:54.930 --> 00:14:55.930
Okay.

00:14:55.930 --> 00:15:00.442
So, now we can see how this works with probably
one of the first encounters you would have

00:15:00.442 --> 00:15:04.900
had with Async stuff which for some weird
reason someone says says you have to call

00:15:04.900 --> 00:15:11.440
setTimeout zero,&nbsp;‑‑ okay, you want me
to run the function in zero time?

00:15:11.440 --> 00:15:12.930
Why would I wrap it in a setTimeout?

00:15:12.930 --> 00:15:17.350
Like the first time you run across this, if
you're like me,i see it doing something, but

00:15:17.350 --> 00:15:20.300
I don't know why.

00:15:20.300 --> 00:15:25.970
The reason is, generally, if you're trying
to defer something until the stack is clear.

00:15:25.970 --> 00:15:29.140
So we know looking at this, if you've written
JavaScript, that we're going to see the same

00:15:29.140 --> 00:15:33.650
result, we're going to see “hi” “JSConf”,
and “there” is going to appear at the

00:15:33.650 --> 00:15:35.480
end.

00:15:35.480 --> 00:15:38.430
We can see how that happens.

00:15:38.430 --> 00:15:44.250
The setTimeout zero, now it's going to complete
immediately and push it on to the queue, remember

00:15:44.250 --> 00:15:47.680
what I said about the event loop, it has to
wait till the stack is clear before it can

00:15:47.680 --> 00:15:53.100
push the callback on to the stack, so your
stack is going to continue to run, console.log

00:15:53.100 --> 00:16:00.720
“hi”, “JSConfEU” and clear, now the
event loop can kick in and call your callback.

00:16:00.720 --> 00:16:07.240
That's like an example of setTimeout zero,
is deferring that execution of code, for whatever

00:16:07.240 --> 00:16:11.040
reason to the end of the stack.

00:16:11.040 --> 00:16:13.150
Or until stack is clear.

00:16:13.150 --> 00:16:14.730
Okay.

00:16:14.730 --> 00:16:21.480
So, all these web APIs work the same way,
if we have AJAX request, we make an AJAX request

00:16:21.480 --> 00:16:28.481
to the URL with a callback, works the same
way, oops sorry, console log, “hi”, make

00:16:28.481 --> 00:16:32.649
an AJAX request, the code for running that
AJAX request does not live in JavaScript Runtime

00:16:32.649 --> 00:16:40.120
but in the browser as a web API, so we spin
it up with a callback in the URL, your code

00:16:40.120 --> 00:16:42.170
can continue to run.

00:16:42.170 --> 00:16:47.460
Until that XHR request completes, or it may
never complete, it's okay, the stack can continue

00:16:47.460 --> 00:16:52.960
to run, assuming it completes, gets pushed
to the queue,picked up by the event loop and

00:16:52.960 --> 00:16:55.970
it's run.

00:16:55.970 --> 00:16:58.360
That's all that happens when an Async call
happens.

00:16:58.360 --> 00:17:05.600
Let's do a crazy complicated example, I hope
this going to work, if you haven't realized

00:17:05.600 --> 00:17:12.450
all this is in keynote there's like I don't
know 500 animation steps in this whole deck.

00:17:12.450 --> 00:17:35.180
(code blows up, flames animation) (Applause)
J Whew ... no ... so ... interesting, we're

00:17:35.180 --> 00:17:38.600
given a link.

00:17:38.600 --> 00:17:42.140
Hmm ... is this big enough, can people see?

00:17:42.140 --> 00:17:52.220
Okay, so basically I wrote this talk for Scotland
JS, after the talk I broke half of the slides

00:17:52.220 --> 00:17:56.360
and could not be bothered to redo all the
slides because it was a total pain in the

00:17:56.360 --> 00:18:05.011
ass in keynote to do it so I took much easier
route (Laughing) of writing a tool that can

00:18:05.011 --> 00:18:11.490
visualize the JavaScript Runtime at Runtime,
and it's called loop.

00:18:11.490 --> 00:18:16.580
So, let's just run this example and, which
was kind of the example that we had on the

00:18:16.580 --> 00:18:23.430
previous slide, I haven't shimmed XHR yet,
it's doable I just haven't done it.

00:18:23.430 --> 00:18:30.960
As you can see the code, we're going to log
something, this is a shim around addEventListener,

00:18:30.960 --> 00:18:33.560
setTimeout and we're going to do a console.log.&nbsp;‑‑

00:18:33.560 --> 00:18:40.179
I'm going to run it and see what happens so
... add a DOM API, add a timeout, code is

00:18:40.179 --> 00:18:49.290
going to continue to run, pushes the callback
into the queue which runs, and we're done.

00:18:49.290 --> 00:18:54.970
If I click on here then it's going to ... trigger
the web API, queue the callback for the click

00:18:54.970 --> 00:18:56.190
and run it.

00:18:56.190 --> 00:18:59.320
if I cluck a hundred times we can see what
happens.

00:18:59.320 --> 00:19:05.350
I clicked, the click doesn't get processed
immediately, itself gets pushed to the queue,

00:19:05.350 --> 00:19:12.300
as the queue gets processed, eventually my
click is going to get dealt with, right.

00:19:12.300 --> 00:19:14.961
So I have a few more examples I'm going to
run through here.

00:19:14.961 --> 00:19:29.280
Here we go, okay, so, I'm just going to run
through a few examples just to kind of talk

00:19:29.280 --> 00:19:33.970
about a few things that you might have run
in to and not thought about with Async APIs,

00:19:33.970 --> 00:19:40.410
In this example we call setTimeout four times
with the one second delay, and console.log

00:19:40.410 --> 00:19:43.470
“hi”.

00:19:43.470 --> 00:19:52.030
By the time the callbacks get queued... that
fourth callback we asked for a one second

00:19:52.030 --> 00:19:56.900
delay, and it's still waiting, the callback
hasn't run, right .

00:19:56.900 --> 00:20:02.470
this illustrates the&nbsp;‑‑ like what time
out is actually doing, it's not a guaranteed

00:20:02.470 --> 00:20:06.880
time to execution, it's a minimum time to
execution, just like setTimeout zero doesn't

00:20:06.880 --> 00:20:16.350
run the code immediately it runs the code
next‑ish, sometime, right?

00:20:16.350 --> 00:20:24.770
So ... in this example I want to talk about
callbacks, so, depending on who, speak to

00:20:24.770 --> 00:20:29.180
and how they phrase things, callbacks can
be one of two things, callbacks can be any

00:20:29.180 --> 00:20:34.760
function that another function calls or callbacks
can be more explicitly an asynchronous callback

00:20:34.760 --> 00:20:39.140
as in one that will get pushed back on the
callback queue in the future.

00:20:39.140 --> 00:20:42.580
This bit of code illustrates the difference,
right.

00:20:42.580 --> 00:20:48.390
The forEach method on an array, it doesn't
run, it takes a function, which you could

00:20:48.390 --> 00:20:55.640
call a callback, but it's not running it asynchronously,
it's running it within the current stack.

00:20:55.640 --> 00:21:02.170
We could define an asynchronous forEach so
it can take an array, a callback and for each

00:21:02.170 --> 00:21:08.250
item in the array it's going to do a setTimeout
zero with that callback, I guess this should

00:21:08.250 --> 00:21:13.770
pass in the value, but any way, so, I'm going
to run it and we can see what the difference

00:21:13.770 --> 00:21:20.500
is, so for the first block of code that runs,
it's going to sit and block the stack, right?

00:21:20.500 --> 00:21:26.080
Until it's complete, whereas in the Async
version, okay, it's slowed down, but we're

00:21:26.080 --> 00:21:31.560
basically going to queue a bunch of callbacks
and they're going to clear and then we can

00:21:31.560 --> 00:21:34.660
actually run through and do a console.log.

00:21:34.660 --> 00:21:39.330
In this example the console.log is fast, so
the benefit of doing it asynchronously is

00:21:39.330 --> 00:21:48.900
not obviously but let's say you're doing some
slow processing on each element in the array.

00:21:48.900 --> 00:21:55.260
I think I have that shown somewhere no, no,
I don't.

00:21:55.260 --> 00:21:56.260
Okay.

00:21:56.260 --> 00:22:00.240
So let's say&nbsp;‑‑ Ooops.

00:22:00.240 --> 00:22:06.620
So I have a delay function which is just slow,
it's just a slow thing.

00:22:06.620 --> 00:22:15.240
So ... let's say processing Async and here
processing Sync.

00:22:15.240 --> 00:22:23.500
Okay, now, I'm going to turn on a thing I've
literally hacked together this morning, which

00:22:23.500 --> 00:22:27.780
is to simulate the repaint or the render in
the browser, something I haven't touched on

00:22:27.780 --> 00:22:34.760
is how all of this interacts with rendering&nbsp;‑‑
I've kind of touched on it but not really

00:22:34.760 --> 00:22:36.430
explained it.

00:22:36.430 --> 00:22:42.330
So, basically the browser is kind of constrained
by what you're doing javaScript, the browser

00:22:42.330 --> 00:22:48.240
would like to repaint the screen every 16.6
milliseconds, 60 frame a second is ideal,

00:22:48.240 --> 00:22:52.880
that's the fastest it will do repaints if
it can.

00:22:52.880 --> 00:22:57.870
But it's constrained by what you're doing
in JavaScript for various reasons, so it can't

00:22:57.870 --> 00:23:02.080
actually do a render if there is code on the
stack, right.

00:23:02.080 --> 00:23:05.230
Like the render kind of call is almost like
a callback in itself.

00:23:05.230 --> 00:23:07.310
It has to wait till the stack is clear.

00:23:07.310 --> 00:23:13.860
The difference is that the render is given
a higher priority than your callback, every

00:23:13.860 --> 00:23:21.480
16 milliseconds it's going to queue a rend,
wait till the stack is clear before it can

00:23:21.480 --> 00:23:23.320
actually do that render.

00:23:23.320 --> 00:23:27.720
So this is&nbsp;‑‑ this render queue is just
simulating a render, every second it's can

00:23:27.720 --> 00:23:28.720
I do a render?

00:23:28.720 --> 00:23:29.940
Yes, can I do a render?

00:23:29.940 --> 00:23:30.940
Yes.

00:23:30.940 --> 00:23:33.130
Where, because our code isn't doing anything
now.

00:23:33.130 --> 00:23:39.910
If I run the code, you can see while we're
doing this slow synchronous loop through the

00:23:39.910 --> 00:23:44.280
array, our render is blocked, right, if our
render is blocked you can't select text on

00:23:44.280 --> 00:23:50.419
the screen, you can't click things and see
the response, right, like the example I showed

00:23:50.419 --> 00:23:51.480
earlier.

00:23:51.480 --> 00:23:57.250
In this example, okay, it's blocked while
we queue up the async time out, that relatively

00:23:57.250 --> 00:24:04.309
quick but we're given&nbsp;‑‑ we're kind of
giving the render a chance between each element

00:24:04.309 --> 00:24:12.591
because we've queued it up asynchronously
to jump in there and do the render, does that

00:24:12.591 --> 00:24:13.591
make sense?

00:24:13.591 --> 00:24:14.760
&gt;&gt; Yeah
&gt;&gt; Yeah, cool.

00:24:14.760 --> 00:24:19.679
So, that's just kind of&nbsp;‑‑ this is just
like a simulation of how the rendering works,

00:24:19.679 --> 00:24:23.600
but it just really shows you when people say
don't block the event loop, this is exactly

00:24:23.600 --> 00:24:24.600
what they're talking about.

00:24:24.600 --> 00:24:27.840
They're saying don't put shitty slow code
on the stack because when you do that the

00:24:27.840 --> 00:24:33.500
browser can't do what it needs to do, create
a nice fluid UI.

00:24:33.500 --> 00:24:38.220
This is why when you're doing things like
image processing or Animating too many things

00:24:38.220 --> 00:24:44.080
gets sluggish if you're not careful about
how you queue up that code.

00:24:44.080 --> 00:24:53.059
So an example of that, we can see with the
scroll handlers&nbsp;‑‑ so scroll handle&nbsp;‑‑

00:24:53.059 --> 00:24:58.600
like scroll events in the DOM trigger a lot,
right, they trigger like&nbsp;‑‑ I presume

00:24:58.600 --> 00:25:04.950
they trigger on every frame like every 16
milliseconds, if I have code like this this

00:25:04.950 --> 00:25:05.950
right.

00:25:05.950 --> 00:25:11.050
On document.scroll, animate something, or
do some work.

00:25:11.050 --> 00:25:16.960
If I have this code, like as I scroll it's
going to queue up like a ton of callbacks

00:25:16.960 --> 00:25:18.090
right.

00:25:18.090 --> 00:25:21.790
And then it has to go through and process
all of those and each of the processing of

00:25:21.790 --> 00:25:27.470
those is slow, then, okay, you're not blocking
the stack, you're flooding the queue with

00:25:27.470 --> 00:25:29.210
queued events.

00:25:29.210 --> 00:25:35.620
So, this is like just helping visualize, I
guess, what happens when you actually trigger

00:25:35.620 --> 00:25:42.290
all these callbacks, there's way you can debounce
that to basically say okay, we're going to

00:25:42.290 --> 00:25:48.419
queue up all those events, but let's do the
slow work every few seconds or until the user

00:25:48.419 --> 00:25:58.059
stops scrolling for some amount of time I
think that's basically it.

00:25:58.059 --> 00:26:03.690
There's a whole other talk in how the hell
this works.

00:26:03.690 --> 00:26:09.540
Because basically in running the code, like
this code runs at Runtime, right, and it's

00:26:09.540 --> 00:26:17.440
slowed down by I run it through a Esprima
a JavaScript parser, I insert a big while

00:26:17.440 --> 00:26:23.840
loop, that takes half a second, it just slow
motions the code.

00:26:23.840 --> 00:26:28.610
Ship it to web worker and do a whole bunch
of stuff to visualize what's happening while

00:26:28.610 --> 00:26:31.179
doing it at run time that makes sense.

00:26:31.179 --> 00:26:33.090
A whole other talk in that.

00:26:33.090 --> 00:26:38.840
I'm super excited about it and will talk to
anyone about it after because I think it's

00:26:38.840 --> 00:26:43.679
kind of neat, so with that, thanks very much
( applause)

